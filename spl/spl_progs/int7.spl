alias i S0;
alias physicalSP S1;
alias sysCallNo S2;

physicalSP = [PTBR + 2*(SP/512)]*512 + (SP%512);
sysCallNo = [physicalSP -1];
i=53;
breakpoint;

if(sysCallNo == 10) then
	alias counter S3;
	counter = 0;
	while(counter<32) do //if no  ready processes, halt the machine
		if([READY_LIST + 32*counter + 1] == 1) then	
			break;
		endif;
		counter = counter + 1;
	endwhile;
	
	if(counter == 32) then
		halt;
	endif;

	alias PID S4;
	PID = (PTBR - 1024)/8; //get the pid of the current process
	
	counter = 0;
	i = READY_LIST + 32*PID + 15;
	while(counter < 8) do //close all open files and reset the per process open file table
		if([i + 2*counter] != -1) then
			[FILE_TABLE + 2*[i + 2*counter] + 1] = [FILE_TABLE + 2*[i+2*counter] + 1] - 1;
			if([FILE_TABLE + 2*[i + 2*counter] + 1] == 0) then
				[FILE_TABLE + 2*[i+ 2*counter]] = -1;
			endif;
		endif;
		[i + 2*counter] = -1;
		[i + 2*counter + 1] = -1;
		counter = counter + 1;
	endwhile;

	[READY_LIST + 32*PID + 1] = 0; //set the state to terminated
	
	counter = 0;
	while(counter < 3) do 
		if([PTBR + 2*counter + 1]=="01" || [PTBR + 2*counter + 1]=="11") then //if valid page, decrement entry in memory free list
			[1280 + [PTBR + 2*counter]] = [1280 + [PTBR + 2*counter]] - 1;
		endif;
		if([PTBR + 2*counter + 1]=="00" || [PTBR + 2*counter + 1]=="10") then //if swap block, decrement entry in disk free list
			if([PTBR + 2*counter]>=448) then
				[6*512 + [PTBR + 2*counter]] = [6*512 + [PTBR + 2*counter]] - 1;
			endif;
		endif;
		[PTBR + 2*counter] = -1; //invalidate page table entries
		[PTBR + 2*counter + 1] = "00";
		counter = counter + 1;
	endwhile;
	
	store(6,20); //commit df back to disk
	
	


//	while(counter < 4) do
//		if([PTBR + 2*counter + 1]=="01" || [PTBR + 2*counter + 1]=="11") then
//			[1280 + [PTBR + 2*counter]] = 0;
//		endif;
//		[PTBR + 2*counter] = -1;
//		[PTBR + 2*counter + 1] = "00";
//		counter = counter + 1;
//	endwhile;
//	i=7;
//	breakpoint;

	counter = (PID + 1)%32; //search for the next ready process
	while(counter !=PID) do
		if([READY_LIST + 32*counter + 1]==1) then	
			break;
		endif;
		counter = (counter + 1)%32;
	endwhile;


	alias newPCB S5;
	newPCB = counter;
	i = READY_LIST + 32*newPCB; //get the register values from the pcb of the new process
	BP = [i + 2];
	SP = [i + 3];
	PTBR = [i + 5];
	PTLR = [i + 6];
	R0 = [i + 7];
	R1 = [i + 8];
	R2 = [i + 9];
	R3 = [i + 10];
	R4 = [i + 11];
	R5 = [i + 12];
	R6 = [i + 13];
	R7 = [i + 14];
	
	SP = SP + 1; //space to store the IP value
	//i = [PTBR + 2*(SP/512)]*512 + (SP%512);
	physicalSP = [PTBR + 2*(SP/512)]*512 + (SP%512);
	[physicalSP] = [i + 4]; //store the IP value on top of the stack
	[i + 1] = 2; //set the state to running
	ireturn;
endif;

