alias physicalSP S0;
alias sysCallNo S1;

physicalSP = [PTBR + (SP/512)]*512 + (SP%512);
sysCallNo = [physicalSP - 1];

if(sysCallNo==8) then
	alias counter S2;
	while(counter<32) do
		if([READY_LIST + 32*counter + 1]==0) then //pcb is free
			break;
		endif;
		counter = counter + 1;
	endwhile;

	if(counter==32) then //no free PCB
		[physicalSP - 2] = -1;
		ireturn;
	endif;

	alias PCBIndex S3;
	PCBIndex = counter;
	[READY_LIST + 32*PCBIndex + 0] = PCBIndex; //set the PID of the child process to the index of the PCB
	
	alias numPages S4;
	numPages = 0;
	counter = 0;
	while(counter<=3) do //find the number of valid pages to be duplicated to the child process
		if([PTBR + 2*counter + 1] == "01" || [PTBR + 2*counter + 1] == "11") then
			numPages = numPages + 1;
		endif;
		counter = counter + 1;
	endwhile;
	
	alias numFreePages S5;
	numFreePages = 0;
	counter = 0;
	while(counter<64) do //find the number of free pages in memory
		if([1280 + counter] == 0) then //free memory page
			numFreePages = numFreePages + 1;
		endif;
		counter = counter + 1;
	endwhile;

	if(numFreePages < numPages) then //not enough free pages to duplicate
		[physicalSP - 2] = -1;
		ireturn;
	endif;

	alias i S6;
	alias pagenum S7;
	alias validpage S8;
	alias childPTBR S9;
	
	childPTBR = PTBR + 8*PCBIndex;
	counter = 0;
	while(counter < 64 && pagenum<numPages) do
		if([1280 + counter] == 0) then
			if([PTBR + pagenum*2 + 1]=="01" || [PTBR + pagenum*2 + 1]=="11") then
				validpage = [PTBR + pagenum*2 + 0];
				i = 0;
				while(i<512) do
					[counter*512 + i] = [validpage*512 + i];
					i = i + 1;
				endwhile;
				[childPTBR + 2*pagenum + 0] = counter;
				[childPTBR + 2*pagenum + 1] = [PTBR + pagenum*2 + 1];
				pagenum = pagenum+1;
			endif;
			else if([PTBR + pagenum*2 + 1]!="01" || [PTBR + pagenum*2 + 1]=="11") then
				[childPTBR + 2*pagenum + 0] = [PTBR + 2*pagenum + 0];
				[childPTBR + 2*pagenum + 1] = [PTBR + 2*pagenum + 1];
				pagenum = pagenum + 1;
			endif;
		endif;
		counter = counter + 1;
	endwhile;

	[READY_LIST + 32*PCBIndex + 5] = childPTBR;
	[READY_LIST + 32*PCBIndex + 4] = [physicalSP];	
	[READY_LIST + 32*PCBIndex + 3] = [PTBR + 32*(PTBR-1024)/8 + 3]-1;
	[READY_LIST + 32*PCBIndex + 2] = BP;
	[READY_LIST + 32*PCBIndex + 6] = PTLR;
	[READY_LIST + 32*PCBIndex + 7] = R0;
	[READY_LIST + 32*PCBIndex + 8] = R1;
	[READY_LIST + 32*PCBIndex + 9] = R2;
	[READY_LIST + 32*PCBIndex + 10] = R3;
	[READY_LIST + 32*PCBIndex + 11] = R4;
	[READY_LIST + 32*PCBIndex + 12] = R5;
	[READY_LIST + 32*PCBIndex + 2] = R6;
	[READY_LIST + 32*PCBIndex + 2] = R7;




	
	
	
				
	
